Here is your **updated Deployment + Service YAML** with **correct CPU/Memory requests + limits** so that your **HPA works perfectly**.

---

# âœ… **UPDATED `icsquiz-user-app.yml` (Final Working Version)**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: icsquiz-user-app
spec:
  selector:
    matchLabels:
      app: icsquiz-user-app
  template:
    metadata:
      labels:
        app: icsquiz-user-app
    spec:
      containers:
        - name: icsquiz-user-app
          image: icsquiz-user-app:latest
          imagePullPolicy: Never
          ports:
            - containerPort: 3090

          envFrom:
            - configMapRef:
                name: global-config

          env:
            - name: SERVER_PORT
              value: "3090"

          # ðŸš€ Added required CPU & Memory requests/limits for HPA to work
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
            limits:
              cpu: "300m"
              memory: "512Mi"

---
apiVersion: v1
kind: Service
metadata:
  name: icsquiz-user-service
spec:
  selector:
    app: icsquiz-user-app
  type: NodePort
  ports:
    - port: 3090
      targetPort: 3090
      nodePort: 30090   # must be between 30000â€“32767
```

---

# ðŸ“Œ What Changed?

### âœ” Added `resources:` section

Without CPU requests, HPA shows `<unknown>`.

### âœ” Requests:

* cpu: **100m**
* memory: **256Mi**

### âœ” Limits:

* cpu: **300m**
* memory: **512Mi**

These values are perfect for a Spring Boot WebFlux app.

---

# ðŸš€ Apply the update

Run:

```
kubectl apply -f /www/wwwroot/CITSNVN/icsQuizUserService/icsquiz-user-app.yml
```

Check HPA:

```
kubectl get hpa
```

You will now see:

```
cpu: 20%/70%
```

Your autoscaling will begin working.

---

If you want, I can also:

âœ… Tune the HPA
âœ… Tune resources based on real usage
âœ… Update Jenkins pipeline with automated rollout

Just tell me: **â€œoptimize everythingâ€**

Here is a **clear, beginner-friendly explanation** of your HPA YAML ðŸ‘‡ðŸ‘‡

---

# ðŸŸ¦ **HorizontalPodAutoscaler (HPA) Explained â€” Line by Line**

This YAML file automatically scales your **Kubernetes Deployment pods** based on **CPU usage**.

---

# ðŸ”µ **Full Meaning of Your HPA YAML**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: icsquiz-user-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: icsquiz-user-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

---

# ðŸ§  **EXPLANATION**

## âœ… `apiVersion: autoscaling/v2`

This uses the latest HPA version with more features.

---

## âœ… `kind: HorizontalPodAutoscaler`

This means the YAML resource is an **autoscaler**.

---

## ðŸ“Œ `metadata.name: icsquiz-user-app-hpa`

This is the **name** of the autoscaler.

---

## ðŸ§© `scaleTargetRef`

This section tells the HPA **which Deployment it should manage**.

```
apiVersion: apps/v1
kind: Deployment
name: icsquiz-user-app
```

So HPA will automatically scale this Deployment:

```
icsquiz-user-app
```

---

## ðŸ“‰ `minReplicas: 2`

Your application **will always run at least 2 pods**
HPA never reduces below this.

---

## ðŸ“ˆ `maxReplicas: 10`

HPA can **scale up to 10 pods maximum** under load.

---

## ðŸ”¥ **The CPU Metric Rule**

This is the most important part:

```
type: Resource
resource:
  name: cpu
  target:
    type: Utilization
    averageUtilization: 70
```

Meaning:

> ðŸ“Œ **If average CPU usage per Pod becomes more than 70%, HPA will create more pods.**
> ðŸ“Œ **If usage drops below 70%, it will scale down â€” but not below 2 pods.**

---

# ðŸ§® **REAL EXAMPLE: How HPA Works**

### ðŸ‘‰ Scenario 1 â€” Load increases

If each pod CPU becomes **85%**:

```
85% > 70% â†’ scale up
```

HPA will create more pods.

---

### ðŸ‘‰ Scenario 2 â€” Load decreases

If CPU usage becomes **30%**:

```
30% < 70% â†’ scale down
```

But minimum is **2 pods**, so it will reduce until 2 pods only.

---

# ðŸŸ¢ Why your HPA was showing `<unknown>` before?

Because:

* Your deployment did NOT have **resources.requests.cpu**
* Without CPU requests, Kubernetes cannot calculate utilization
* HPA cannot measure CPU properly â†’ **<unknown>**

Now we fixed it by adding:

```yaml
resources:
  requests:
    cpu: "100m"
```

So HPA will now calculate:

```
(actual_cpu_usage / requested_cpu) * 100
```

---

# ðŸŽ¯ Final Result

Your HPA will now:

* Keep **2â€“10 pods**
* Monitor **average CPU**
* Increase pods if CPU > 70%
* Reduce pods if CPU < 70%

---

If you want, I can also:

âœ… Tune proper CPU/memory values
âœ… Add HPA based on **memory** or **custom metrics**
âœ… Add **prometheus metrics**
âœ… Add **load test script** to check auto-scaling

Just type: **â€œoptimize my autoscalingâ€**




